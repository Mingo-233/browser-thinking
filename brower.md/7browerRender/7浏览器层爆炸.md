## 1 页面渲染的流程

## 经典问题-从输入 URL 到页面展示，这中间发生了什么？ 

   1. 用户输入url并回车    
   2. 浏览器进程检查url，组装协议，构成完整的url。 触发beforeunload钩子    
   3. 浏览器进程通过进程间通信（IPC）把url请求发送给网络进程    
   4. 网络进程接收到url请求后检查本地缓存是否缓存了该请求资源，如果有则将该资源返回给浏览器进程   
   5. 如果没有，网络进程向web服务器发起http请求（网络请求），请求流程如下：        5.1 进行DNS解析，获取服务器ip地址        5.2 利用ip地址和服务器建立tcp连接        5.3 构建请求头信息        5.4 发送请求头信息        5.5 服务器响应后，网络进程接收响应头和响应信息，并解析响应内容-   
   6. 网络进程解析响应流程；        6.1 检查状态码，如果是301/302，则需要重定向，从Location自动中读取地址，重新进行第4步      如果是200，则继续处理请求。        6.2 200响应处理：            检查响应类型Content-Type，如果是字节流类型，则将该请求提交给下载管理器，该导航流程结束，不再进行            后续的渲染，如果是html则通知浏览器进程准备渲染进程准备进行渲染。    7，准备渲染进程       
   7. 浏览器进程检查当前url是否和之前打开的渲染进程根域名是否相同，如果相同，则复用原来的进程，如果不同，则开启新的渲染进程   
   8. 传输数据、更新状态        8.1 渲染进程准备好后，浏览器向渲染进程发起“提交文档”的消息，渲染进程接收到消息和网络进程建立传输数据的“管道”        8.2 渲染进程接收完数据后，向浏览器发送“确认提交”        8.3 浏览器进程接收到确认消息后更新浏览器界面状态：安全、地址栏url、前进后退的历史状态、更新web页面   
   9. 页面渲染  
	1. 渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构。                
	2. 渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，然后计算出 DOM树中每个节点的样式。(包含css继承规则和层叠规则的处理)  
	3. 创建布局树，并计算元素的布局信息、节点的坐标位置。  
	4. 对布局树进行分层，并生成分层树。渲染引擎需要为特定的节点生成专用的图层，并生成一棵对应的图层树。如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。满足2个条件的元素将提升为单独的图层：第一点，拥有层叠上下文属性的元素会被提升为单独的一层。（明确定位属性的元素、定义透明属性的元素、使用 CSS 滤镜的元素等，都拥有层叠上下文属性。）第二点，需要剪裁（clip）的地方也会被创建为图层。 （例如overflow）  
	5. 为每个图层生成绘制列表，（会把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表，比如绘制蓝色背景；在中间绘制一个红色的圆；再在圆上绘制绿色三角形。）并将其提交到合成线程。  
	6. 合成线程将图层分成图块（图块是栅格化执行的最小单位，通常就是256x256 或者 512x512的一块区域），图块按照绘制列表中的指令生成，并在光栅化线程池中进行栅格化处理。所谓栅格化，是指将图块转换为位图。 合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。
	7. 一旦所有图块都被光栅化，合成线程发送绘制图块命令 DrawQuad 给浏览器进程。  
	8. 浏览器进程根据 DrawQuad 消息生成页面绘制到内存中，最后再将内存显示在屏幕上。

 简单来说，初次渲染时会经过以下几步
1. 构建DOM树；
2. 样式计算；
3. 布局定位；
4. 图层分层；
5. 图层绘制；
6. 合成显示；

在CSS属性改变时，重渲染会分为“回流”、“重绘”和“直接合成”三种情况，分别对应从“布局定位”/“图层绘制”/“合成显示”开始，再走一遍上面的流程。

元素的CSS具体发生什么改变，则决定属于上面哪种情况：


1重绘：修改了一些不影响布局的属性，比如颜色；
2回流（又叫重排）：元素位置、大小发生变化导致其他节点联动，需要重新计算布局；
3直接合成：合成层的transform、opacity修改，只需要将多个图层再次合并，而后生成位图，最终展示到屏幕上；


## 渲染中的层

上面提到了渲染过程中会发生“图层分层”。浏览器中的层分为两种：“渲染层”和“合成层（也叫复合层）”。很多文章中还会提到一个概念叫“图形层”，其实可以把它当作合成层看待。

先直观的感受一下“层”，打开浏览器开发者工具的layers:

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b04c17d2d2f24450b8f9c8d73ae09610~tplv-k3u1fbpfcp-watermark.image?)

layers.html

可以看到AB元素都在最底下的图层中，元素C是单独的一层，元素D又是一层。


之前说过，浏览器中的层分两种，渲染层和合成层，在开发者工具看到的全部都是合成层。
那么，怎样生成一个渲染层，又怎样才能形成一个合成层呢？

## 层叠上下文
层叠上下文听起来比较抽象，我们假定用户正面向（浏览器）视窗或网页，而 HTML 元素沿着其相对于用户的一条虚构的 z 轴排开，层叠上下文就是对这些 HTML 元素的一个三维构想。众 HTML 元素基于其元素属性按照优先级顺序占据这个空间。
也可以理解为，层叠上下文是html中某些元素的一个特殊属性，这个属性决定了他在空间的上下位置，而这个位置会影响到他们的渲染顺序。

最大的层叠上下文就是由文档根元素——html形成的：它自身连同它的子元素就形成了一个最大的层叠上下文，也就是说，我们写的所有代码都是在根层叠上下文里的。

层叠上下文包含多个平面，具体来说：每个z-index的值形成一个平面，普通的无定位的块级元素也是一个平面，浮动元素也是一个平面，正是这些平面形成了层叠上下文。

除此之外，每个有z-index数值的元素也会连同它的子元素一起，生成一个小的层叠上下文，这个小层叠上下文和父级一样，拥有多个平面。

去处理这些上下文时，我们可以按照从小到大的顺序递归：先把最小的堆叠上下文中元素的顺序理好，拍成一片——当做一个整体，再与父级的堆叠上下文中其他元素比较。

层级问题2.html
![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/81978fcc72f3486a81f9d6a5b9d2b936~tplv-k3u1fbpfcp-watermark.image?)
## 渲染层
渲染层的概念跟“层叠上下文”密切相关，简单来说，拥有z-index属性的定位元素会生成一个层叠上下文，一个生成层叠上下文的元素就生成了一个渲染层。


还是沿用上面的例子，BCD三个元素都是拥有z-index属性的定位元素（绝对定位），所以他们三个都形成了一个渲染层，加上document根元素形成的，一共是四个渲染层。（再强调一下，在开发者工具中看不到渲染层。）

形成渲染层的条件也就是形成层叠上下文的条件，有这几种情况：

1. document 元素
2. 拥有z-index属性的定位元素（position: relative|fixed|sticky|absolute）
3. 弹性布局的子项（父元素display:flex|inline-flex)，并且z-index不是auto时
4. opacity非1的元素
5. transform非none的元素
6. filter非none的元素
7. will-change = opacity | transform | filter
8. 此外需要剪裁的元素也会形成一个渲染层，也就是overflow不是visible的元素

## 合成层
只有一些特殊的渲染层才会被提升为合成层，通常来说有这些情况：

1. document根元素
2. transform:3D变换：translate3d，translateZ；
3. will-change:opacity | transform | filter
4. 对 opacity | transform | fliter 应用了过渡和动画（transition/animation）
5. video、canvas、iframe
6. 可滚动溢出元素，scrollable overflow

可以看出，上面这些条件属于生成渲染层的“加强版”，也就是说形成合成层的条件要更苛刻。

还是用开头的例子，C元素就是命中条件1，使用了3D变换transform: translateZ(0)，于是被提升到一个单独的合成层。

但是D元素没有命中上面任何一条规则，却也是一个单独的合成层。因为还有一种情况——隐式合成。

## 隐式合成
当出现一个合成层后，层级顺序高于它的堆叠元素就会发生隐式合成。

我们给C、D元素设置层级，z-index分别是3和4；又在C元素上使用3D变换，提升成了合成层。此时，层级高于它的D元素就发生了隐式合成，也变成了一个合成层。

隐式合成出现的根本原是，元素发生了堆叠，浏览器为了保证最后的展示效果，不得不把层级顺序更高的元素拎出来盖在已有合成层上面。
## 层爆炸与层压缩
这是我在项目中实际遇到的一个问题：一个页面在低端机器上滚动时非常卡顿，排查了很久，最后发现原因就在于隐式合成带来的层爆炸。

隐式合成产生了很多预期外的合成层——页面中所有 z-index 高于它的节点全部被提升，这些合成层都是相当消耗内存和GPU的。所以带给我们的启示是给合成层一个大的z-index值，避免出现隐式合成。

还好浏览器逐渐进行了优化，也就是层压缩机制——多个渲染层同一个合成层重叠时，会自动将他们压缩到一起，避免“层爆炸”带来的损耗。