## 1 chrome打开一个tab页面有几个进程？

### 1单进程浏览器
我们知道js是单线程的语言，一次只能做一件事。早期的浏览器也是单进程浏览器，但是这样有很多问题，主要是3个方面：不稳定、不流畅、不安全。
 * 不稳定：浏览器中经常会装很多插件，而插件的开发很多都是个人开发的，有很多的隐患在，所以有时候会崩溃，因为是单进程，插件崩溃了，整个页面就崩溃了。 
 * 不流畅：比如某个页面js代码中有一块死循环了，那么就会一直执行这个代码块，另外地方的代码都没有机会执行了，另外页面也会受到影响。另外运行一个复杂点的页面再关闭页面，会存在内存不能完全回收的情况，这样导致的问题是使用时间越长，内存占用越高，浏览器会变得越慢，即使没有再打开那个有内存泄露问题的网页，但是浏览器仍然会越用越卡。 
 * 不安全：一些恶意脚本会访问计算机本地的文件，有时候甚至篡改文件，因此有很大的安全隐患。

### 2多进程浏览器
![image.png](./assets//%E5%A4%9A%E8%BF%9B%E7%A8%8B.png)
* 浏览器进程。主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。
* 渲染进程。核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。因为渲染进程所有的内容都是通过网络获取的，会存在一些恶意代码利用浏览器漏洞对系统进行攻击，所以运行在渲染进程里面的代码是不被信任的。  

* GPU 进程。其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。  
* 网络进程。面向渲染进程和浏览器进程等提供网络下载功能。
* 插件进程。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。

多进程浏览器是如何解决了之前的问题的。

1. 不稳定的问题。由于进程是相互隔离的，所以当一个页面或者插件崩溃时，影响到的仅仅是当前的页面进程或者插件进程，并不会影响到浏览器和其他页面，这就完美地解决了页面或者插件的崩溃会导致整个浏览器崩溃，也就是不稳定的问题。

2. 不流畅的问题是如何解决的。同样，JavaScript 也是运行在渲染进程中的，所以即使 JavaScript 阻塞了渲染进程，影响到的也只是当前的渲染页面，而并不会影响浏览器和其他页面，因为其他页面的脚本是运行在它们自己的渲染进程中的。所以当我们再在 Chrome 中运行上面那个死循环的脚本时，没有响应的仅仅是当前的页面。对于内存泄漏的解决方法那就更简单了，因为当关闭一个页面时，整个渲染进程也会被关闭，之后该进程所占用的内存都会被系统回收，这样就解决了浏览器页面的内存泄漏问题。

3. 安全问题。采用多进程架构的额外好处是可以使用安全沙箱，你可以把沙箱看成是操作系统给进程上了一把锁，沙箱里面的程序可以运行，但是不能在你的硬盘上写入任何数据，也不能在敏感位置读取任何数据，例如你的文档和桌面。Chrome 把插件进程和渲染进程锁在沙箱里面，这样即使在渲染进程或者插件进程里面执行了恶意程序，恶意程序也无法突破沙箱去获取系统权限。

## 2经典问题-从输入 URL 到页面展示，这中间发生了什么？ 

关于这道问题，大家都有所听闻，但是大多数人可能回答其中部分零散的知识点，并不能将这些知识点串联成线，或者问的细致一点，有些问题可能就不太清楚了，例如：

1合成层的“层”与层叠上下文的“层”是一个东西吗？
2层爆炸、层压缩是什么？
3都说要减少回流、重绘，怎样利用硬件加速做到？

导航过程
   1. 用户输入url并回车    
   2. 浏览器进程检查url，组装协议，构成完整的url。 触发beforeunload钩子    
   3. 浏览器进程通过进程间通信（IPC）把url请求发送给网络进程    
   4. 网络进程接收到url请求后检查本地缓存是否缓存了该请求资源，如果有则将该资源返回给浏览器进程   
   5. 如果没有，网络进程向web服务器发起http请求（网络请求），请求流程如下：        5.1 进行DNS解析，获取服务器ip地址        5.2 利用ip地址和服务器建立tcp连接        5.3 构建请求头信息        5.4 发送请求头信息        5.5 服务器响应后，网络进程接收响应头和响应信息，并解析响应内容-   
   6. 网络进程解析响应流程；        6.1 检查状态码，如果是301/302，则需要重定向，从Location自动中读取地址，重新进行第4步      如果是200，则继续处理请求。        6.2 200响应处理：            检查响应类型Content-Type，如果是字节流类型，则将该请求提交给下载管理器，该导航流程结束，不再进行            后续的渲染，如果是html则通知浏览器进程准备渲染进程准备进行渲染。    7，准备渲染进程       
   7. 浏览器进程检查当前url是否和之前打开的页面是否为同一站点（根域名（例如，baoxiaohe.com）加上协议都相同），如果相同，则复用原来的渲染进程，如果不同，则开启新的渲染进程   
   8. 传输数据、更新状态        8.1 渲染进程准备好后，浏览器向渲染进程发起“提交文档”的消息，渲染进程接收到消息和网络进程建立传输数据的“管道”        8.2 渲染进程接收完数据后，向浏览器发送“确认提交”        8.3 浏览器进程接收到确认消息后更新浏览器界面状态：安全、地址栏url、前进后退的历史状态、更新web页面   (这也就解释了为什么在浏览器的地址栏里面输入了一个地址后，之前的页面没有立马消失，而是要加载一会儿才会更新页面。)

渲染过程
   9. 页面渲染  
	1. 渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构。                
	2. 渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，然后计算出 DOM树中每个节点的样式。(包含css继承规则和层叠规则的处理)  
	3. 创建布局树，并计算元素的布局信息、节点的坐标位置。  
	4. 对布局树进行分层，并生成分层树。渲染引擎需要为特定的节点生成专用的图层，并生成一棵对应的图层树。如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。满足2个条件的元素将提升为单独的图层：第一点，拥有层叠上下文属性的元素会被提升为单独的一层。（明确定位属性的元素、定义透明属性的元素、使用 CSS 滤镜的元素等，都拥有层叠上下文属性。）第二点，需要剪裁（clip）的地方也会被创建为图层。 （例如overflow）  
	5. 为每个图层生成绘制列表，（会把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表，比如绘制蓝色背景；在中间绘制一个红色的圆；再在圆上绘制绿色三角形。）并将其提交到合成线程。  
	6. 合成线程将图层分成图块（图块是栅格化执行的最小单位，通常就是256x256 或者 512x512的一块区域），图块按照绘制列表中的指令生成，并在光栅化线程池中进行栅格化处理。所谓栅格化，是指将图块转换为位图。 合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。
	7. 一旦所有图块都被光栅化，合成线程发送绘制图块命令 DrawQuad 给浏览器进程。  
	8. 浏览器进程根据 DrawQuad 消息生成页面绘制到内存中，最后再将内存显示在屏幕上。

决定浏览器将以什么形式、什么编码读取这个文件
    Content-Type: 
    text/html; charset=utf-8
    application/octet-stream ： 二进制流数据（如常见的文件下载）


![image.png](./assets/%E9%A1%B5%E9%9D%A2%E7%BB%98%E5%88%B6%E7%A4%BA%E6%84%8F%E5%9B%BE.webp)