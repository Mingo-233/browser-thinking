# 一、 在chrome中打开一个浏览器，为什么有4个进程。
1首先，理清进程和线程之间的关系。线程是包含在在进程里面的。 两者之间最主要的关系有4点：1进程中任意线程崩溃，会导致整个进程崩溃 2线程中的数据是可以共享的 3进程结束时会回收系统的内存，这样就有一个好处，在某个线程的存在内存泄漏的情况，当进程关闭时，这些泄漏的内存就会返还。 4进程之间的内容相互隔离，比如浏览器中的一个tab页崩溃了，其他tab页是不受影响的。但是一定要通信的话，也是可以利用IPC协议进行通信的。

2单进程浏览器 ，我们知道js是单线程的语言，一次只能做一件事。早期的浏览器也是单进程浏览器，但是这样有很多问题，主要是3个方面：不稳定、不流畅、不安全。 不稳定：浏览器中经常会装很多插件，而插件的开发很多都是个人开发的，有很多的隐患在，所以有时候会崩溃，因为是单进程，插件崩溃了，整个页面就崩溃了。 不流畅：比如js代码中有一块死循环了，那么就会一直执行这个代码块，另外地方的代码都没有机会执行了，或者存在一些内存泄漏的问题，浏览器就会越用越卡。 不安全：一些恶意脚本会访问计算机本地的文件，有时候甚至篡改文件，因此有很大的安全隐患。

3多进程浏览器，打开一个页面，4个进程分布是浏览器的主进程，渲染进程、Gpu进程、网络进程，如果存在插件，那么还有插件进程。单进程浏览器的问题，在这里也得到了很好的解决。稳定性：因为存在了多进程，进程之间是相互隔离的，所以某个进程的崩溃不会影响到整个浏览器。 流畅性：JavaScript是运行在渲染进程中的，当他堵塞了，不会影响到其他进程，内存的泄漏的问题也很好解决，当关闭一个tab页的时候，也就相当于关闭整个进程，内存就会被回收。 安全性：多进程的额外好处就是可以使用沙箱隔离，插件进程和渲染进程都放在沙箱中运行，无法读写计算机的文件等信息。
# 二、为什么很多站点第二次打开会很快
1dns缓存2页面资源缓存

# osi七层模型
赢了一个表回来，传往我叔的屋子里面。  
 对应就是 应-表-会-传-网-数-物应用层-表示层-会话层-传输层-网络层-数据链路层-物理层
 
# 三、从输入 URL 到页面展示，这中间发生了什么？  
   1. 用户输入url并回车    
   2. 浏览器进程检查url，组装协议，构成完整的url。 触发beforeunload钩子    
   3. 浏览器进程通过进程间通信（IPC）把url请求发送给网络进程    
   4. 网络进程接收到url请求后检查本地缓存是否缓存了该请求资源，如果有则将该资源返回给浏览器进程   
   5. 如果没有，网络进程向web服务器发起http请求（网络请求），请求流程如下：        5.1 进行DNS解析，获取服务器ip地址，端口（端口是通过dns解析获取的吗？这里有个疑问）        5.2 利用ip地址和服务器建立tcp连接        5.3 构建请求头信息        5.4 发送请求头信息        5.5 服务器响应后，网络进程接收响应头和响应信息，并解析响应内容-   
   6. 网络进程解析响应流程；        6.1 检查状态码，如果是301/302，则需要重定向，从Location自动中读取地址，重新进行第4步            （301/302跳转也会读取本地缓存吗？这里有个疑问），如果是200，则继续处理请求。        6.2 200响应处理：            检查响应类型Content-Type，如果是字节流类型，则将该请求提交给下载管理器，该导航流程结束，不再进行            后续的渲染，如果是html则通知浏览器进程准备渲染进程准备进行渲染。    7，准备渲染进程       
   7. 浏览器进程检查当前url是否和之前打开的渲染进程根域名是否相同，如果相同，则复用原来的进程，如果不同，则开启新的渲染进程   
   8. 传输数据、更新状态        8.1 渲染进程准备好后，浏览器向渲染进程发起“提交文档”的消息，渲染进程接收到消息和网络进程建立传输数据的“管道”        8.2 渲染进程接收完数据后，向浏览器发送“确认提交”        8.3 浏览器进程接收到确认消息后更新浏览器界面状态：安全、地址栏url、前进后退的历史状态、更新web页面   
   9. 页面渲染  
	1. 渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构。                
	2. 渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，然后计算出 DOM树中每个节点的样式。(包含css继承规则和层叠规则的处理)  
	3. 创建布局树，并计算元素的布局信息、节点的坐标位置。  
	4. 对布局树进行分层，并生成分层树。渲染引擎需要为特定的节点生成专用的图层，并生成一棵对应的图层树。如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。满足2个条件的元素将提升为单独的图层：第一点，拥有层叠上下文属性的元素会被提升为单独的一层。（明确定位属性的元素、定义透明属性的元素、使用 CSS 滤镜的元素等，都拥有层叠上下文属性。）第二点，需要剪裁（clip）的地方也会被创建为图层。 （例如overflow）  
	5. 为每个图层生成绘制列表，（会把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表，比如绘制蓝色背景；在中间绘制一个红色的圆；再在圆上绘制绿色三角形。）并将其提交到合成线程。  
	6. 合成线程将图层分成图块（图块是栅格化执行的最小单位，通常就是256x256 或者 512x512的一块区域），并在光栅化线程池中将图块转换成位图。 合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，就是按照绘制列表中的指令生成图片
	7. 一旦所有图块都被光栅化，合成线程发送绘制图块命令 DrawQuad 给浏览器进程。  
	8. 浏览器进程根据 DrawQuad 消息生成页面绘制到内存中，最后再将内存显示在屏幕上。

## 减少重排重绘, 方法很多：
	1. 使用 class 操作样式，而不是频繁操作 style。（利用浏览器的渲染队列）
	2. 批量dom 操作，例如 createDocumentFragment，或者使用框架
	3. 对 dom 属性的读写要分离 （因为当读的时候为了拿到样式数据，会直接执行渲染队列，你分开读写，你每次读都会执行一次。如果你全部先写，再读，只会重新渲染一次）
	4. transform 做优化。CSS 的 transform 来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作

 
 ## 渲染引擎生成一帧图像有三种方式：重排、重绘和合成
# 四、变量提升、函数提升
JavaScript 的执行机制：**先编译，再执行**
1. JavaScript 代码执行过程中，需要先做变量提升，而之所以需要实现变量提升，是因为 JavaScript 代码在执行之前需要先编译。
2. 在编译阶段，变量和函数会被存放到变量环境中，变量的默认值会被设置为 undefined；在代码执行阶段，JavaScript 引擎会从变量环境中去查找自定义的变量和函数。
3. 如果在编译阶段，存在两个相同的函数。    
  a:如果是同名的函数，JavaScript编译阶段会选择最后声明的那个。因为后定义的会覆盖掉之前定义的     
  b:如果变量和函数同名，那么在编译阶段，变量的声明会被忽略.(且函数提升的优先级高于变量提升)
  ```
showName()
var showName = function() {
    console.log(2)
}
function showName() {
    console.log(1)
}
```
使用let 或者const 声明的话会使用块级作用域的规制，会直接报错

## ES6 是如何做到既要支持变量提升的特性，又要支持块级作用域的呢?

块级作用域就是通过词法环境的栈结构来实现的，而变量提升是通过变量环境来实现，通过这两者的结合.
* 函数内部通过 var 声明的变量，在编译阶段全都被存放到变量环境里面了。
* 通过 let 声明的变量，在编译阶段会被存放到词法环境（Lexical Environment）中。
* 在函数的作用域块内部，通过 let 声明的变量并没有被存放到词法环境中。  
  
具体查找方式是：沿着词法环境的栈顶向下查询，如果在词法环境中的某个块中查找到了，就直接返回给 JavaScript 引擎，如果没有查找到，那么继续在变量环境中查找。其实在词法环境内部，维护了一个小型栈结构

## 暂时性死区
```
let myname= '极客时间'
{
  console.log(myname)  // Uncaught ReferenceError: Cannot access 'myname' before initialization
  let myname= '极客邦'
}
```
输出结果是报错，这是因为变量在编译阶段会做「创建」「初始化」2件事，在执行阶段会做「赋值」 这件事。在块作用域内，let声明的变量被提升，但变量只是创建被提升，初始化并没有被提升，在初始化之前使用变量，JavaScript引擎会抛出错误---这就是“暂时性死区”。

【拓展】  
var的创建和初始化被提升，赋值不会被提升。  
let的创建被提升，初始化和赋值不会被提升。  
function的创建、初始化和赋值均会被提升。  

# 五、作用域链
先看一题，打印的是什么？
```
function bar() {
    console.log(myName)
}
function foo() {
    var myName = "极客邦"
    bar()
}
var myName = "极客时间"
foo()
```
答案：极客时间

为什么？

首先，很多人的第一想法就是根据调用栈的顺序来查找变量，bar函数的执行上下文找myName，然后到foo函数找，然后到全局作用域找。但事实不是这样。

其实在每个执行上下文的变量环境中，都包含了一个外部引用，用来指向外部的执行上下文，我们把这个外部引用称为 outer。当一段代码使用了一个变量时，JavaScript 引擎首先会在“当前的执行上下文”中查找该变量，比如上面那段代码在查找 myName 变量时，如果在当前的变量环境中没有查找到，那么 JavaScript 引擎会继续在 outer 所指向的执行上下文中查找。
**根据outer指向查找的链条就称为作用域链。**

那么这个作用域链的顺序是由什么决定的呢？

还需要知道另一个概念**词法作用域**，词法作用域就是指作用域是由代码中**函数声明的位置**来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符。


词法作用域就是根据代码的位置来决定的， 也就是说，词法作用域是代码编译阶段就决定好的，和函数是怎么调用的没有关系。 就比如bar和foo函数，都是在全局下声明的，所以他们的outer指向的都是全局作用域，当 当前作用域找不到myName这个变量的时候，就会根据作用域链向上找。

案例二
```
function bar() {
    var myName = "极客世界"
    let test1 = 100
    if (1) {
        let myName = "Chrome浏览器"
        console.log(test)
    }
}
function foo() {
    var myName = "极客邦"
    let test = 2
    {
        let test = 3
        bar()
    }
}
var myName = "极客时间"
let myAge = 10
let test = 1
foo()
```
案例三
```
var bar = {
    myName:"time.geekbang.com",
    printName: function () {
        console.log(myName)
    }    
}
function foo() {
    let myName = "极客时间"
    return bar.printName
}
let myName = "极客邦"
let _printName = foo()
_printName()
bar.printName()
```


## 关于闭包问题

当一个函数存在闭包，当这个函数被销毁的时候，他的栈上下文都被销毁了，但是他闭包的数据是存在堆当中的，而且最最关键的一点事，除了当前函数栈上下文存在对闭包堆的引用，还有全局或者说上级的上下文对象对闭包堆存在引用，所以及时函数内部的栈引用被销毁了，闭包数据也不会被内存回收掉，因此仍然存在引用关系。

六、垃圾回收机制

首先分为 栈内存回收和堆内存回收。  
## 栈内存回收
通过ESP 指针移动来销毁，当一个函数执行结束之后，JavaScript 引擎会通过向下移动 ESP 来销毁该函数保存在栈中的执行上下文。

## 堆内存回收
分为主垃圾回收器和副垃圾回收器。在副垃圾回收器中，划分为2个区域，一个是新生代区域（很小，通常只有1-8mb），一个是老生代区域。   

### 老生代区域
清理步骤1标记非活动对象2清除非活动对象3整理内存（因为回收对象后会存在不连续的内存空间，也成为内存碎片）。   
由于 JavaScript 是运行在主线程之上的，一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做全停顿（Stop-The-World）。 流程 js->标记->清除->整理->js

为了降低老生代的垃圾回收而造成的卡顿，V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为增量标记（Incremental Marking）算法。  流程 js->标记1->js->标记2->js->清除->整理->js
### 新生代区域
通过Scavenge 算法，分为空闲区域和对象区域，将活动的对象复制到空闲区域，然后清空对象区域。那个复制操作也就相当于整理了内存碎片。 完成之后反转两边的区域位置，如果两次都在空闲区域保留下来的对象，将移动到老生代区域。
