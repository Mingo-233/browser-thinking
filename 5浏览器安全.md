# 一、XSS

XSS 全称是 Cross Site Scripting，为了与“CSS”区分开来，故简称 XSS，翻译过来就是“跨站脚本”。XSS 攻击是指黑客往 HTML 文件中或者 DOM 中注入恶意脚本，从而在用户浏览页面时利用注入的恶意脚本对用户实施攻击的一种手段。
## 存储型 XSS 攻击
存储型 XSS 攻击大致需要经过如下步骤：  
1首先黑客利用站点漏洞将一段恶意 JavaScript 代码提交到网站的数据库中；  
2然后用户向网站请求包含了恶意 JavaScript 脚本的页面；   
3当用户浏览该页面的时候，恶意脚本就会将用户的 Cookie 信息等数据上传到服务器。

解决办法： 

## 反射型 XSS 攻击
恶意 JavaScript 脚本属于用户发送给网站请求中的一部分，随后网站又把恶意 JavaScript 脚本返回给用户。当恶意 JavaScript 脚本在用户页面中被执行时，黑客就可以利用该脚本做一些恶意操作。

比如我把一个恶意脚本卸载链接后面，发到网站上，别人点了这个链接进去就会触发恶意脚本。

Web 服务器不会存储反射型 XSS 攻击的恶意脚本，这是和存储型 XSS 攻击不同的地方。
## 基于 DOM 的 XSS 攻击
黑客通过各种手段将恶意脚本注入用户的页面中，比如通过网络劫持在页面传输过程中修改 HTML 页面的内容，这种劫持类型很多，有通过 WiFi 路由器劫持的，有通过本地恶意软件来劫持的，它们的共同点是在 Web 资源传输过程或者在用户使用页面的过程中修改 Web 页面的数据。

## 解决办法：
1. 不要相信用户的任何输入，对用户输入内容进行检查、过滤和转义。
2. HttpOnly HttpOnly 是服务器通过 HTTP 响应头来设置的，使用 HttpOnly 标记的 Cookie 只能使用在 HTTP 请求过程中，所以无法通过 JavaScript 来读取这段 Cookie。

# 二、CSRF
跨站请求伪造,CSRF 攻击是攻击者借助受害者的 Cookie 骗取服务器的信任，可以在受害者毫不知情的情况下以受害者名义伪造请求发送给受攻击服务器，从而在并未授权的情况下执行在权限保护之下的操作。

一个疑问：受浏览器同源政策影响，在另一个伪造网址发送请求，为什么能到正规网站返回给用户的session。
如果是CSRF攻击，那么黑客是拿不到受害者站点数据的。但是黑客会在他的A站点中调用受害者B站点的http接口，这些接口可以是转账，删帖或者设置等。这个过程中你需要注意一点，在黑客A站点中调用受害者B站点的http接口时，默认情况下，浏览器依然会把受害者的Cookie等信息数据发送到受害者的B站点，【注意这里并不是黑客的A站点】。如果B站点存在漏洞的话，那么黑客就会攻击成功，比如将受害者的金币转出去了！

## 解决办法：
1. Cookie 的 SameSite 属性。在 HTTP 响应头中，通过 set-cookie 字段设置 Cookie 时，可以带上 SameSite 选项，如下：
```
set-cookie: 1P_JAR=2019-10-20-06; expires=Tue, 19-Nov-2019 06:36:21 GMT; path=/; domain=.google.com; SameSite=none
```
SameSite 选项通常有 Strict、Lax 和 None 三个值。  
Strict 最为严格。如果 SameSite 的值是 Strict，那么浏览器会完全禁止第三方 Cookie。简言之，如果你从极客时间的页面中访问 InfoQ 的资源，而 InfoQ 的某些 Cookie 设置了 SameSite Strict 的话，那么这些 Cookie 是不会被发送到 InfoQ 的服务器上的。只有你从 InfoQ 的站点去请求 InfoQ 的资源时，才会带上这些 Cookie。     
Lax 相对宽松一点。在跨站点的情况下，从第三方站点的链接打开和从第三方站点提交 Get 方式的表单这两种方式都会携带 Cookie。但如果在第三方站点中使用 Post 方法，或者通过 img、iframe 等标签加载的 URL，这些场景都不会携带 Cookie。  
而如果使用 None 的话，在任何情况下都会发送 Cookie 数据。

2. 验证请求的来源站点   
由服务器端验证当前请求的来源站点，HTTP 请求头中的 Referer 和 Origin 属性

Origin 属性只包含了域名信息，并没有包含具体的 URL 路径，这是 Origin 和 Referer 的一个主要区别。

3. CSRF Token

第一步，在浏览器向服务器发起请求时，服务器生成一个 CSRF Token，存到前端。
 
第二步，在浏览器端如果要发起转账的请求或敏感操作时，那么需要带上页面中的 CSRF Token，然后服务器会验证该 Token 是否合法。如果是从第三方站点发出的请求，那么将无法获取到 CSRF Token 的值，所以即使发出了请求，服务器也会因为 CSRF Token 不正确而拒绝请求。


# 三、安全沙箱

设计现代浏览器体系架构时，将浏览器划分为不同的进程是为了增加其稳定性。虽然设计成了多进程架构，不过这些模块之间的沟通方式却有些复杂，也许你还有以下问题：

1为什么一定要通过浏览器内核去请求资源，再将数据转发给渲染进程，而不直接从进程内部去请求网络资源？

2为什么渲染进程只负责生成页面图片，生成图片还要经过 IPC 通知浏览器内核模块，然后让浏览器内核去负责展示图片？

通过以上方式不是增加了工程的复杂度吗？

首先现在的浏览器内核被划分为浏览器内核和渲染内核两个核心模块，浏览器内核包含了网络线程、GPU进程、浏览器进程。 所有的与系统相关的操作或者id操作都是在浏览器内核中进行的，例如（cookie存储、cache存储、文件下载、文件读取、网络请求等），而渲染内核中的渲染进程做哪些？（html、css解析、js、布局、绘制）。

安全沙箱最小的保护单位是进程，所以被安全沙箱保护的进程就是渲染进程。在网络上你下载一个恶意程序，如果你不去执行他是不会有任何影响的，只有你去执行了才会有破坏，而浏览器中执行的这一步就是渲染进程去做的。

## 站点隔离（Site Isolation）
所谓站点隔离是指 Chrome 将同一站点（包含了相同根域名和相同协议的地址）中相互关联的页面放到同一个渲染进程中执行。

最开始 Chrome 划分渲染进程是以标签页为单位，也就是说整个标签页会被划分给某个渲染进程。但是，按照标签页划分渲染进程存在一些问题，原因就是一个标签页中可能包含了多个 iframe，而这些 iframe 又有可能来自于不同的站点，这就导致了多个不同站点中的内容通过 iframe 同时运行在同一个渲染进程中。

比如一个网站有ABC三个iframe，其中a Iframe存在漏洞问题或者恶意程序，但是此时他们在一个渲染进程中，就有可能会对其他网站造成影响。因为沙箱隔离当前情况下只针对渲染进程，而他们却都在一个渲染进程下。

实现了站点隔离，就可以将恶意的 iframe 隔离在恶意进程内部，使得它无法继续访问其他 iframe 进程的内容，因此也就无法攻击其他站点了。