# 一、 在chrome中打开一个浏览器，为什么有4个进程。
1首先，理清进程和线程之间的关系。线程是包含在在进程里面的。 两者之间最主要的关系有4点：1进程中任意线程崩溃，会导致整个进程崩溃 2线程中的数据是可以共享的 3进程结束时会回收系统的内存，这样就有一个好处，在某个线程的存在内存泄漏的情况，当进程关闭时，这些泄漏的内存就会返还。 4进程之间的内容相互隔离，比如浏览器中的一个tab页崩溃了，其他tab页是不受影响的。但是一定要通信的话，也是可以利用IPC协议进行通信的。

2单进程浏览器 ，我们知道js是单线程的语言，一次只能做一件事。早期的浏览器也是单进程浏览器，但是这样有很多问题，主要是3个方面：不稳定、不流畅、不安全。 不稳定：浏览器中经常会装很多插件，而插件的开发很多都是个人开发的，有很多的隐患在，所以有时候会崩溃，因为是单进程，插件崩溃了，整个页面就崩溃了。 不流畅：比如js代码中有一块死循环了，那么就会一直执行这个代码块，另外地方的代码都没有机会执行了，或者存在一些内存泄漏的问题，浏览器就会越用越卡。 不安全：一些恶意脚本会访问计算机本地的文件，有时候甚至篡改文件，因此有很大的安全隐患。

3多进程浏览器，打开一个页面，4个进程分布是浏览器的主进程，渲染进程、Gpu进程、网络进程，如果存在插件，那么还有插件进程。单进程浏览器的问题，在这里也得到了很好的解决。稳定性：因为存在了多进程，进程之间是相互隔离的，所以某个进程的崩溃不会影响到整个浏览器。 流畅性：JavaScript是运行在渲染进程中的，当他堵塞了，不会影响到其他进程，内存的泄漏的问题也很好解决，当关闭一个tab页的时候，也就相当于关闭整个进程，内存就会被回收。 安全性：多进程的额外好处就是可以使用沙箱隔离，插件进程和渲染进程都放在沙箱中运行，无法读写计算机的文件等信息。
# 二、为什么很多站点第二次打开会很快
1dns缓存2页面资源缓存

# osi七层模型
赢了一个表回来，传往我叔的屋子里面。  
 对应就是 应-表-会-传-网-数-物应用层-表示层-会话层-传输层-网络层-数据链路层-物理层
 
# 三、从输入 URL 到页面展示，这中间发生了什么？  
   1. 用户输入url并回车    
   2. 浏览器进程检查url，组装协议，构成完整的url。 触发beforeunload钩子    
   3. 浏览器进程通过进程间通信（IPC）把url请求发送给网络进程    
   4. 网络进程接收到url请求后检查本地缓存是否缓存了该请求资源，如果有则将该资源返回给浏览器进程   
   5. 如果没有，网络进程向web服务器发起http请求（网络请求），请求流程如下：        5.1 进行DNS解析，获取服务器ip地址，端口（端口是通过dns解析获取的吗？这里有个疑问）        5.2 利用ip地址和服务器建立tcp连接        5.3 构建请求头信息        5.4 发送请求头信息        5.5 服务器响应后，网络进程接收响应头和响应信息，并解析响应内容-   
   6. 网络进程解析响应流程；        6.1 检查状态码，如果是301/302，则需要重定向，从Location自动中读取地址，重新进行第4步            （301/302跳转也会读取本地缓存吗？这里有个疑问），如果是200，则继续处理请求。        6.2 200响应处理：            检查响应类型Content-Type，如果是字节流类型，则将该请求提交给下载管理器，该导航流程结束，不再进行            后续的渲染，如果是html则通知浏览器进程准备渲染进程准备进行渲染。    7，准备渲染进程       
   7. 浏览器进程检查当前url是否和之前打开的渲染进程根域名是否相同，如果相同，则复用原来的进程，如果不同，则开启新的渲染进程   
   8. 传输数据、更新状态        8.1 渲染进程准备好后，浏览器向渲染进程发起“提交文档”的消息，渲染进程接收到消息和网络进程建立传输数据的“管道”        8.2 渲染进程接收完数据后，向浏览器发送“确认提交”        8.3 浏览器进程接收到确认消息后更新浏览器界面状态：安全、地址栏url、前进后退的历史状态、更新web页面   
   9. 页面渲染  
	1. 渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构。                
	2. 渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，然后计算出 DOM树中每个节点的样式。(包含css继承规则和层叠规则的处理)  
	3. 创建布局树，并计算元素的布局信息、节点的坐标位置。  
	4. 对布局树进行分层，并生成分层树。渲染引擎需要为特定的节点生成专用的图层，并生成一棵对应的图层树。如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。满足2个条件的元素将提升为单独的图层：第一点，拥有层叠上下文属性的元素会被提升为单独的一层。（明确定位属性的元素、定义透明属性的元素、使用 CSS 滤镜的元素等，都拥有层叠上下文属性。）第二点，需要剪裁（clip）的地方也会被创建为图层。 （例如overflow）  
	5. 为每个图层生成绘制列表，（会把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表，比如绘制蓝色背景；在中间绘制一个红色的圆；再在圆上绘制绿色三角形。）并将其提交到合成线程。  
	6. 合成线程将图层分成图块（图块是栅格化执行的最小单位，通常就是256x256 或者 512x512的一块区域），并在光栅化线程池中将图块转换成位图。 合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图  
	7. 一旦所有图块都被光栅化，合成线程发送绘制图块命令 DrawQuad 给浏览器进程。  
	8. 浏览器进程根据 DrawQuad 消息生成页面绘制到内存中，最后再将内存显示在屏幕上。

## 减少重排重绘, 方法很多：
	1. 使用 class 操作样式，而不是频繁操作 style。（利用浏览器的渲染队列）
	2. 批量dom 操作，例如 createDocumentFragment，或者使用框架
	3. 对 dom 属性的读写要分离 （因为当读的时候为了拿到样式数据，会直接执行渲染队列，你分开读写，你每次读都会执行一次。如果你全部先写，再读，只会重新渲染一次）
	4. transform 做优化。CSS 的 transform 来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作

四、关于闭包问题

当一个函数存在闭包，当这个函数被销毁的时候，他的栈上下文都被销毁了，但是他闭包的数据是存在堆当中的，而且最最关键的一点事，除了当前函数栈上下文存在对闭包堆的引用，还有全局或者说上级的上下文对象对闭包堆存在引用，所以及时函数内部的栈引用被销毁了，闭包数据也不会被内存回收掉，因此仍然存在引用关系。